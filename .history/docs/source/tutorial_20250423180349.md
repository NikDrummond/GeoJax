# GeoJax Mathematical Foundations: A Beginner-Friendly Tutorial

> Learn the math and geometry powering **GeoJax** step-by-step. With LaTeX math, code examples, and intuitive explanations.


## Table of Contents

## Vectors and Vector Operations {#vectors-and-vector-operations}

## Projections and Reflections {#projections-and-reflections}

## Rotation and Orientation {#rotation-and-orientation}

## Coordinate Alignment {#coordinate-alignment}

## Bounding Shapes {#bounding-shapes}

## Geometric Checks and Basis Vectors {#geometric-checks-and-basis-vectors}

## Circular Statistics {#circular-statistics}

## Mahalanobis Distance and Outliers {#mahalanobis-distance-and-outliers}

---

## Vectors and Vector Operations

### Magnitude
The **length** of a vector \( \vec{v} = [x, y, z] \) is:

$$
\|\vec{v}\| = \sqrt{x^2 + y^2 + z^2}
$$

In GeoJax:
```python
magnitude(v)
```

### Dot Product
The dot product between \( \vec{a} \cdot \vec{b} \) gives:

$$
\vec{a} \cdot \vec{b} = \|a\|\|b\| \cos(\theta)
$$

Use:
```python
dot(a, b)
```

### Cross Product
Gives a vector \( \vec{a} \times \vec{b} \) orthogonal to both:

```python
cross(a, b)
```

---

## Projections and Reflections

### Projection onto a Vector
To project \( \vec{v} \) onto \( \vec{u} \):

$$
\text{proj}_u(v) = \frac{\vec{v} \cdot \vec{u}}{\|\vec{u}\|^2} \vec{u}
$$

```python
project_to_vector(v, u)
```

### Reflection across a Plane
Reflect \( \vec{v} \) across a plane normal \( \vec{n} \):

$$
\vec{v}_{\text{reflected}} = \vec{v} - 2(\vec{v} \cdot \vec{n})\vec{n}
$$

```python
reflect(v, n)
```

---

## Rotation and Orientation

### Rotation Around Axis
Rotate vector \( \vec{v} \) by angle \( \theta \) around axis \( \vec{u} \):

```python
rotate_around_axis(v, u, theta)
```

### Rotation Between Vectors
Construct matrix to rotate \( \vec{a} \) to \( \vec{b} \):

```python
rotation_matrix_between_vectors(a, b)
```

---

## Coordinate Alignment

### PCA / Eigendecomposition
Given 3D points:

1. Compute covariance matrix
2. Extract eigenvectors (axes)
3. Align by transforming into eigenbasis

```python
coord_eig_decomp(points)
align_point_cloud(points, order="xyz")
```

---

## Bounding Shapes

### AABB (Axis-Aligned Bounding Box)

```python
aabb_bounds(points)
```

### Bounding Sphere

```python
bounding_sphere(points)
```

### Oriented Bounding Box (OBB)
Based on eigen decomposition:

```python
oriented_bounding_box(points)
```

---

## Geometric Checks and Basis Vectors

### Unit, Orthogonal, Collinear

```python
is_unit_vector(v)
is_orthogonal(a, b)
is_collinear(a, b)
```

### Canonical Basis

```python
from GeoJax import basis
basis.x, basis.y, basis.z
```

---

## Circular Statistics

Circular mean of \( \theta_i \in [0, 2\pi) \):

$$
\bar{\theta} = \text{atan2}\left(\sum \sin(\theta_i), \sum \cos(\theta_i)\right)
$$

```python
circmean(angles)
circstd(angles)
circvar(angles)
```

---

## Mahalanobis Distance and Outliers

Mahalanobis distance:

$$
D_M(x) = \sqrt{(x - \mu)^T \Sigma^{-1} (x - \mu)}
$$

Outlier detection with chi-squared threshold:

```python
outliers = detect_outliers_mahalanobis(X, alpha=0.99)
```

---

## Next Steps

- Try applying to point clouds
- Use with JAX for differentiable pipelines
- Visualize bounding shapes
- Extend with your own geometry utilities!

> ðŸ§  Built for scientists, ML devs, and roboticists using **JAX**.

---

## ðŸ“š Documentation

See the full API docs at: `docs/`

Or build them locally:
```bash
cd docs
make html
```

